## 01-基础入门

### 第二章

#### 1. 刷一个底色

整体代码

```html
<canvas id="canvas"></canvas>
<script>
	const canvas = document.getElementById('canvas')
  const gl = canvas.getContext('webgl')
  // 设置颜色缓冲区颜色，使用颜色缓冲区颜色清空画布
  gl.clearColor(0,0,0,1)
  gl.clear(gl.COLOR_BUFFER_BIT)
</script>
```

#### 2. css颜色转换成rgba颜色(手动版)

转换代码

```js
// css 转换成 webgl 颜色
function switchCssColorToWebglColor (rgbaStr) {
  const cssRgba = rgbaStr.replace(/(.*)\((.*)\)/, '$2')
  const keyArr = ['r', 'g', 'b', 'a']
  return cssRgba.split(',').reduce((res, cur, index) => {
    return {
      ...res,
      [keyArr[index]]: index === 3 ? +cur : +cur / 255
    }
  }, {})
}
const { r, g, b, a } = switchCssColorToWebglColor('rgba(255, 0, 0, 1)')
gl.clearColor(r, g, b, a)
gl.clear(gl.COLOR_BUFFER_BIT)
```

#### 3. webgl坐标系的

##### 3.1 canvas2d画布的坐标系

首先原点是 画布的左上角， 然后每个单位是以像素位单位

##### 3.2 webgl的坐标系

原点在画布的中心点， 然后x的上的 1个单位表示的是 画布的 宽度的一半， y上的1个单位表示的是 画布的 高度的一半



### 第三章 webgl 绘制一个点

#### 1. 绘图的基本步骤

webgl绘制图形步骤对比现实中需要的东西：

+ 一个电脑
+ 一块手绘板
+ 一个触控笔
+ 开始画画

我们使用触控笔在手绘板上进行绘制，然后再到电脑中进行渲染

这里多了一个手绘板？

#### 2. canvas2d和webgl绘图的差异

浏览器的三大线程： Js引擎线程，GUI渲染线程，浏览器事件触发线程

其中GUI渲染线程负责渲染，这个里面有负责不同渲染的工人，比如 html+css渲染工人，二维图像渲染工人，有负责三维渲染工人

二维和三维渲染使用的语言是不一样的

二维使用的是js语言， 三维使用的是GLSL ES语言

所以我们用的js创建出来的三维画笔不能直接渲染，需要一个类似翻译的东西(手绘板)， 这个东西就是 webgl 中的 **程序对象**

#### 3. webgl的绘图思路

1. 找一台电脑 - 浏览器里的内置webgl渲染引擎，负责渲染webgl, 它只认识 GLSL ES语言
2. 找一块手绘板 - 程序对象， 承载GLSL ES语言， 翻译 GLSL ES语言 和 js语言，使两者可以相互通信
3. 找一只触控笔 - 通过 canvas 获取webgl类型的上下文对象，可以通过手绘板传递绘图命令，并接受手绘板的状态信息
4. 开始画画 - 通过webgl类型的上下文对象， 使用 js 来 画画

#### 4. Webgl的绘图步骤



#### 5. 着色器

##### 5.1 着色器的概念

webgl绘图需要两种着色器

+ 顶点着色器(Vertex shader)： 描述顶点的特征， 如：位置，颜色等等
+ 片元着色器(fragment shader):  进行逐片元处理 如：光照

翻译一下 **顶点** 和 **片元**，两点决定一条直线，其中的两点就是顶点，而两点之间的所有的点就是片元

##### 5.2 着色器语言 glsl

顶点着色器中的内置变量

+ Vec4() gl_Position
+ Float  gl_PointSize

片元着色器中内置变量

+ Vec4 () gl_FragColor

#### 6. 着色器初始化

初始化着色器的步骤：

1. 建立程序对象

   ```js
   const program = gl.createProgram()
   ```

2. 建立顶点着色器对象和片元着色器对象

   ```js
   const vertexShader = loaderShader(gl, gl.VERTEX_SHADER, vsSource)
   const fragmentShader = loaderShader(gl, gl.FRAGMENT_SHADER, fsSource)
   ```

3. 将顶点着色器和片元着色器挂在到 程序对象中

   ```js
   gl.attachShader(program, vertexShader)
   gl.attachShader(program, fragmentShader)
   ```

4. 连接webgl上下文对象和程序对象

   ```js
   gl.linkProgram(program)
   ```

5. 启动程序对象

   ```js
   gl.useProgram(program)
   ```

其中第二步的加载着色器对象的方法如下

```js
function loaderShader(gl, type, source) {
  const shader = gl.createShader(type)
  gl.shaderSource(shader, source)
  gl.compileShader(shader)
  return shader
}
```



## 02- 单元

### 目标

1. 使用js向着色器传递参数
2. 获取鼠标在canvas中的webgl坐标系位置

### 第一章 用js控制点的位置

#### 1. js通过attribute变量向顶点着色器传递参数

传递参数的步骤

1. 在着色器中声明一个变量

   ```glsl
   attribute vec4 a_Position;
   void main() {
     gl_Position = a_Position;
     gl_PonitSize = 10.0;
   }
   ```

2. 在js中获取 attribute的存储位置

   ```js
   const a_Position = gl.vertexAttribLocation(gl.program, 'a_Position')
   ```

   这里程序对象起的的翻译的作用就是，把你这个attribute变量存储的位置给我下

3. 在js中设置attribuge的值

   ```js
   gl.vertexAttrib3f(a_Position, 0.0,0.5,0.0)
   ```

#### 2. 扩展

##### vertexAttrib3f的同族函数

+ vertexAttrib1f(location, x)
+ vertexAttrib2f(location, x, y)
+ vertexAttrib3f(location, x, y, z)
+ vertexAttrib4f(location, x, y ,z, a)

### 第二章 通过鼠标设置点的位置

#### 点击绘制单个点

1. 获取鼠标在 canvas 上的 c s s点位

   ```js
   canvas.addEventListener('click', ({clientX, clientY}) => {
     // 获取点在 canvas 中的css位置
     const { left, top, width, height }  = canvas.getBoundingClientRect()
     const [cssX, cssY] = [clientX - left, clientY - top]
     //...
   })
   ```

2. 相对于webgl坐标系中心点位置

   ```js
   const [centerX, centerY] = [width /2, height /2]
   const [xBaseCenter, yBaserCenter] = [cssX - centerX, cssY - centerY]
   ```

3. 处理Y轴的差异

   ```js
   const yBaserCenterTop = - yBaserCenter
   ```

4. 处理webgl坐标系中单位问题

   ```js
   const [x, y] = [xBaserCenter / centerX, yBaseCenterTop / centerY]
   ```

5. 绘制点位

   ```js
   gl.vertexAttrib2f(x, y)
   gl.clearColor(0,0,0,1)
   gl.clear(gl.COLOR_BUFFER_BIT)
   gl.drawArrays(gl.POINTS, 0, 1)
   ```

   

#### 点击绘制多个点

##### 1. 同步绘制原理

webgl绘制会现在颜色缓冲区中进行绘制，当需要渲染时会按照颜色缓冲区中内容进行绘制，当我们执行异步线程的时候，颜色缓冲区会被重置，之前绘制的东西也就没有了

#####  2. 绘制多个点

设置一个数组，然后同步渲染

##### 3. js修改定顶点大小

和修改位置一样，通过attribute变量，传递参数到 顶点着色器的内置变量 gl_PointSize



### 第三章 用js控制顶点颜色

#### 1. 用js 控制顶点颜色步骤

1. 在片元着色器里把控制顶点顶点颜色的变量暴露粗来

   ```html
   <script id="fragmentShader" type="x-shader/x-fragment">
   	precision mediump float; // 设置精度， 这里就是 设置浮点类型的精度为中等
   	uniform vec4 u_FragColor;
   	void main() {
   		gl_FragColor=u_FragColor;
   	}
   </script>
   ```

2. 在j s中获取到片元着色器暴露的位置

   ```js
   const u_FragColor = gl.getUniformLocation(gl.program, 'u_FragColor')
   ```

3. 修改uniform变量

   ```js
   gl.uniform4f(u_FragColor, 1.0,1.0,1.0, 1.0)
   ```



### 案例-用鼠标绘制星空

#### 1. 用鼠标绘制圆形的顶点

重新理解一下片元着色器的概念，我们绘制了一个顶点，这个点不是一下子就绘制出来的，而是逐片元(像素)，一个个渲染，最后组成了这个顶点，在逐个像素渲染的时候都会调用一次 main 方法

绘制一个圆形的顶点

```html
<script id="fragmentShader" type="x-shader/x-fragment">
	percision mediump float;
	uniform vec4 u_FragColor;
	void main() {
		float dist = distance(gl_PointCoord, vec2(0.5, 0.5));
		if(dist < 0.5) {
			gl_FragColor = u_FragColor;
		} else {
			discard;
		}
	}
</script>
```

+ disance(p1, p2), 计算两个点的距离
+ gl_PointCoord  获取片元在一个点中的位置(在一个点中，片元位置为 0 - 1 的取值内)
+ discard 丢弃，不会渲染这个片元

着色器语法地址：x x x





