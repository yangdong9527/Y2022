## 01-基础入门

### 第二章

#### 1. 刷一个底色

整体代码

```html
<canvas id="canvas"></canvas>
<script>
	const canvas = document.getElementById('canvas')
  const gl = canvas.getContext('webgl')
  // 设置颜色缓冲区颜色，使用颜色缓冲区颜色清空画布
  gl.clearColor(0,0,0,1)
  gl.clear(gl.COLOR_BUFFER_BIT)
</script>
```

#### 2. css颜色转换成rgba颜色(手动版)

转换代码

```js
// css 转换成 webgl 颜色
function switchCssColorToWebglColor (rgbaStr) {
  const cssRgba = rgbaStr.replace(/(.*)\((.*)\)/, '$2')
  const keyArr = ['r', 'g', 'b', 'a']
  return cssRgba.split(',').reduce((res, cur, index) => {
    return {
      ...res,
      [keyArr[index]]: index === 3 ? +cur : +cur / 255
    }
  }, {})
}
const { r, g, b, a } = switchCssColorToWebglColor('rgba(255, 0, 0, 1)')
gl.clearColor(r, g, b, a)
gl.clear(gl.COLOR_BUFFER_BIT)
```

#### 3. webgl坐标系的

##### 3.1 canvas2d画布的坐标系

首先原点是 画布的左上角， 然后每个单位是以像素位单位

##### 3.2 webgl的坐标系

原点在画布的中心点， 然后x的上的 1个单位表示的是 画布的 宽度的一半， y上的1个单位表示的是 画布的 高度的一半



### 第三章 webgl 绘制一个点

#### 1. 绘图的基本步骤

webgl绘制图形步骤对比现实中需要的东西：

+ 一个电脑
+ 一块手绘板
+ 一个触控笔
+ 开始画画

我们使用触控笔在手绘板上进行绘制，然后再到电脑中进行渲染

这里多了一个手绘板？

#### 2. canvas2d和webgl绘图的差异

浏览器的三大线程： Js引擎线程，GUI渲染线程，浏览器事件触发线程

其中GUI渲染线程负责渲染，这个里面有负责不同渲染的工人，比如 html+css渲染工人，二维图像渲染工人，有负责三维渲染工人

二维和三维渲染使用的语言是不一样的

二维使用的是js语言， 三维使用的是GLSL ES语言

所以我们用的js创建出来的三维画笔不能直接渲染，需要一个类似翻译的东西(手绘板)， 这个东西就是 webgl 中的 **程序对象**

#### 3. webgl的绘图思路

1. 找一台电脑 - 浏览器里的内置webgl渲染引擎，负责渲染webgl, 它只认识 GLSL ES语言
2. 找一块手绘板 - 程序对象， 承载GLSL ES语言， 翻译 GLSL ES语言 和 js语言，使两者可以相互通信
3. 找一只触控笔 - 通过 canvas 获取webgl类型的上下文对象，可以通过手绘板传递绘图命令，并接受手绘板的状态信息
4. 开始画画 - 通过webgl类型的上下文对象， 使用 js 来 画画

#### 4. Webgl的绘图步骤



#### 5. 着色器

##### 5.1 着色器的概念

webgl绘图需要两种着色器

+ 顶点着色器(Vertex shader)： 描述顶点的特征， 如：位置，颜色等等
+ 片元着色器(fragment shader):  进行逐片元处理 如：光照

翻译一下 **顶点** 和 **片元**，两点决定一条直线，其中的两点就是顶点，而两点之间的所有的点就是片元

##### 5.2 着色器语言 glsl

顶点着色器中的内置变量

+ Vec4() gl_Position
+ Float  gl_PointSize

片元着色器中内置变量

+ Vec4 () gl_FragColor

#### 6. 着色器初始化

初始化着色器的步骤：

1. 建立程序对象

   ```js
   const program = gl.createProgram()
   ```

2. 建立顶点着色器对象和片元着色器对象

   ```js
   const vertexShader = loaderShader(gl, gl.VERTEX_SHADER, vsSource)
   const fragmentShader = loaderShader(gl, gl.FRAGMENT_SHADER, fsSource)
   ```

3. 将顶点着色器和片元着色器挂在到 程序对象中

   ```js
   gl.attachShader(program, vertexShader)
   gl.attachShader(program, fragmentShader)
   ```

4. 连接webgl上下文对象和程序对象

   ```js
   gl.linkProgram(program)
   ```

5. 启动程序对象

   ```js
   gl.useProgram(program)
   ```

其中第二步的加载着色器对象的方法如下

```js
function loaderShader(gl, type, source) {
  const shader = gl.createShader(type)
  gl.shaderSource(shader, source)
  gl.compileShader(shader)
  return shader
}
```



## 02- 单元

### 目标

1. 使用js向着色器传递参数
2. 获取鼠标在canvas中的webgl坐标系位置

### 第一章 用js控制点的位置

#### 1. js通过attribute变量向顶点着色器传递参数

传递参数的步骤

1. 在着色器中声明一个变量

   ```glsl
   attribute vec4 a_Position;
   void main() {
     gl_Position = a_Position;
     gl_PonitSize = 10.0;
   }
   ```

2. 在js中获取 attribute的存储位置

   ```js
   const a_Position = gl.vertexAttribLocation(gl.program, 'a_Position')
   ```

   这里程序对象起的的翻译的作用就是，把你这个attribute变量存储的位置给我下

3. 在js中设置attribuge的值

   ```js
   gl.vertexAttrib3f(a_Position, 0.0,0.5,0.0)
   ```

#### 2. 扩展

##### vertexAttrib3f的同族函数

+ vertexAttrib1f(location, x)
+ vertexAttrib2f(location, x, y)
+ vertexAttrib3f(location, x, y, z)
+ vertexAttrib4f(location, x, y ,z, a)

### 第二章 通过鼠标设置点的位置

#### 点击绘制单个点

1. 获取鼠标在 canvas 上的 c s s点位

   ```js
   canvas.addEventListener('click', ({clientX, clientY}) => {
     // 获取点在 canvas 中的css位置
     const { left, top, width, height }  = canvas.getBoundingClientRect()
     const [cssX, cssY] = [clientX - left, clientY - top]
     //...
   })
   ```

2. 相对于webgl坐标系中心点位置

   ```js
   const [centerX, centerY] = [width /2, height /2]
   const [xBaseCenter, yBaserCenter] = [cssX - centerX, cssY - centerY]
   ```

3. 处理Y轴的差异

   ```js
   const yBaserCenterTop = - yBaserCenter
   ```

4. 处理webgl坐标系中单位问题

   ```js
   const [x, y] = [xBaserCenter / centerX, yBaseCenterTop / centerY]
   ```

5. 绘制点位

   ```js
   gl.vertexAttrib2f(x, y)
   gl.clearColor(0,0,0,1)
   gl.clear(gl.COLOR_BUFFER_BIT)
   gl.drawArrays(gl.POINTS, 0, 1)
   ```

   

#### 点击绘制多个点

##### 1. 同步绘制原理

webgl绘制会现在颜色缓冲区中进行绘制，当需要渲染时会按照颜色缓冲区中内容进行绘制，当我们执行异步线程的时候，颜色缓冲区会被重置，之前绘制的东西也就没有了

#####  2. 绘制多个点

设置一个数组，然后同步渲染

##### 3. js修改定顶点大小

和修改位置一样，通过attribute变量，传递参数到 顶点着色器的内置变量 gl_PointSize



### 第三章 用js控制顶点颜色

#### 1. 用js 控制顶点颜色步骤

1. 在片元着色器里把控制顶点顶点颜色的变量暴露粗来

   ```html
   <script id="fragmentShader" type="x-shader/x-fragment">
   	precision mediump float; // 设置精度， 这里就是 设置浮点类型的精度为中等
   	uniform vec4 u_FragColor;
   	void main() {
   		gl_FragColor=u_FragColor;
   	}
   </script>
   ```

2. 在j s中获取到片元着色器暴露的位置

   ```js
   const u_FragColor = gl.getUniformLocation(gl.program, 'u_FragColor')
   ```

3. 修改uniform变量

   ```js
   gl.uniform4f(u_FragColor, 1.0,1.0,1.0, 1.0)
   ```



### 案例-用鼠标绘制星空

#### 1. 用鼠标绘制圆形的顶点

重新理解一下片元着色器的概念，我们绘制了一个顶点，这个点不是一下子就绘制出来的，而是逐片元(像素)，一个个渲染，最后组成了这个顶点，在逐个像素渲染的时候都会调用一次 main 方法

绘制一个圆形的顶点

```html
<script id="fragmentShader" type="x-shader/x-fragment">
	percision mediump float;
	uniform vec4 u_FragColor;
	void main() {
		float dist = distance(gl_PointCoord, vec2(0.5, 0.5));
		if(dist < 0.5) {
			gl_FragColor = u_FragColor;
		} else {
			discard;
		}
	}
</script>
```

+ disance(p1, p2), 计算两个点的距离
+ gl_PointCoord  获取片元在一个点中的位置(在一个点中，片元位置为 0 - 1 的取值内)
+ discard 丢弃，不会渲染这个片元

着色器语法地址：x x x

#### 2. 绘制星空， 绘制不同透明度的片元

注意直接设置透明度发现没有变化， 需要开启颜色合成 设置颜色合成方式

```js
gl.enable(gl.BLEND)
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
```



#### 3. 添加补间动画， 让星星眨眼睛







## 03-单元 绘制三角形

### 绘制点线面

#### 1. 绘制多个点

**缓冲区对象：**缓冲区对象是WebGL系统中的一块内存区域，我们可以一次性的向缓冲区对象中填充大量的顶点数据， 然后将这些数据保存其中，供顶点着色器使用

##### 使用缓冲区对象

使用缓冲区对象向顶点着色器传入多个顶点的数据，需要遵循以下五个步骤

+ 创建缓冲区对象(gl.createBuffer())
+ 绑定缓冲区对象(gl.bindBuffer(target, buffer))
+ 将数据写入缓冲区对象(gl.bufferData(target, data, usage))
+ 将缓冲区对象分配给一个attribute变量(gl.vertexAttribPointer())
+ 开启 attribute 变量(gl.enableertexAttribArray())

##### 创建缓冲区对象

使用`gl.createBuffer()`方法会在 WebGL 系统内部创建出一个 **缓冲区对象**

```js
var vertexBuffer = gl.createBuffer()
```

##### 绑定缓冲区

将**缓冲区对象**绑定到WebGL系统中已经存在的 **目标上**这个目标就是表示缓冲区对象的用途

目标有：

+ gl.ARRAY_BUFFER   表示缓冲区对象中包含 顶点的数据
+ gl.ELEMENT_ARRAY_BUFFER 表示缓冲对象中包含了顶点的索引

```js
gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
```

##### 向缓冲区对象中写入数据

使用`gl.bufferData(target, data, usage)`，我们只能向**目标**中写入数据，所以需要先将缓冲区绑定到目标上，才会写入到缓冲区中

参数

+ target    gl.ARRAY_BUFFER 或 gl.ELEMENT_ARRAY_BUFFER
+ Data      写入缓冲区对象的数据(类型化数组)
+ usage    表示程序程序将如何使用存储在缓冲区中的数据，该参数只是为了优化操作
  + gl.STATIC_DRAW     只会想缓冲区对象中写入一次数据， 但需要绘制很多次
  + gl.STREAM_DRAW   只会想缓冲区对象中写入一次数据，然后绘制若干次
  + gl.DYNAMIC_DRAW. 会想缓冲区对象中写入多次数据，并绘制很多次

`类型化数组`和Array数组相似， 但是不支持 push() 和 pop() 方法，支持的方法和常量

+ get(index)  或第 index 个值
+ set(index, value) 设置第几个值为 value
+ Set(array, offset). 从第 offset 个元素开始，将数组 array 中的值填充进去
+ length.    长度

```js
const vertices = new Float32Array([
  0.0, 0.5, -0.5, -0.5, 0.5, -0.5
])
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
```

##### 将缓冲区对象分配给attribute变量(gl.vertexAttribPointer())

你可以通过`gl.vertexAttrib[1234]f`系列函数为 attribute 变量分配值， 但是一次只能向变量传输一个值

`gl.vertexAttribPointer()`方法可以将整个缓冲区对象 分配给 attribute 变量

`gl.vertexAttribPointer(location, size, type, normalized, stride, offset)`方法

+ location.      指定待分配的 attribute 变量的存储位置
+ size。           指定缓冲区中每个顶点的分量个数， 若size比 attribute 变量需要的分量小，则自动补全，  1-3。补的是 0，   4分量补。1
+ type。          指定数据格式
  + gl.FLOAT   浮点型。  Float32Array
  + gl.UNSIGNED_BYTE.  无符号字节。Uint8Array
  + gl.SHORT     短数型。 Int16Array
  + gl.INT。    整型。  Int32Array
  + gl.UNSIGNED_INt   无符号整型。Uint32Array
+ Normalize。  传入 true 或 false,  表示是否将非浮点型的数据 归一到[0,1]或[-1,1]
+ s t ride。      指定相邻两个顶点间的字节数
+ offset.        指定缓冲区对象中的偏移量， 即 attribute 变量从缓冲区何处开始存储

```js
gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0, 0)
```

##### 开启 attribute 变量

`gl.enableVertexArray(location)`传入一个已经分配好缓冲区的 attribute 变量后，我们开启， 这时 缓冲区对象和 attribute 变量之间链接就真正的建立起来了

```js
gl.enableVertexArrty(a_Position)
```

##### gl.drawArrays 第二个和第三个参数

第二个参数表示 从第几个点开始绘制，  第三个参数表示 绘制几个点

##### 绘制多个点总结

1. 首先使用 `var vertesBuffer = gl.createBuffer()`在weggl系统中场景一个缓冲区对象空间
2. 然后将`gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)`，这个缓冲对象绑定到WebGL系统中的**目标**上
3. 然后将 数据通过 **目标**写入到 缓冲区对象中，`gl.bufferData(gl.ARRAY_BUFFER,vertices, gl.STATIC_DRAW)`
4. 这时后将缓冲区对象 分配给 attribute 变量， `gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, 0,0)` 和之前的方法相比较，这个方法可以传入多个顶点
5. 开启 这个 attribute 和 缓冲区对象链接`gl.enableVertexAttribArray(a_Position)`
6. `gl.drawArray(gl.POINT, 0,3)`



#### 绘制三角面

先把点的大小去掉

```glsl
//gl_PointSize = 10.0;
```

然后修改绘图方式

```js
gl.drawArrays(gl.TRIANGlES, 0 , 3)
```



#### 其他图形的绘制(点线面 绘制的规律)

##### gl.drawArrays 的mode 参数

+ gl.POINTS
+ gl.LINES
+ gl.LINE_STRIP
+ gl.LINE_LOOP
+ gl.TRIANGLES  这个绘制的是一系列单独的三角形 （v0,v1,v2）,(v3,v4,v5)
+ gl.TRIANGLE_START(三角带) 会共享一条变，
  + 第一个三角形 按照顺序进行绘制
  + 第偶数个三角形，以上一个三角形的第二条边 + 下一个点为基础，以和第二条边相反的方向绘制三角形
  + 第奇数个三角形，以上一个三角形的第三条边 + 下一个点为基础，以和第二条边相反的方向绘制三角形

+ gl.TRIANGLE_FAN  三角扇
  + 第一个三角形 按顺序进行绘制
  + 以上一个三角形的第三条边 + 下一个点为基础， 以第三条边的相反方向进行绘制


##### 面的绘制

面的基本原理

+ 面有正反两面
+ 面向我们的面 如果是正面，他是逆时针绘制的，如果是反面，他是顺时针绘制的



### 异步绘制

我们手动创建的 缓冲区对象 不像，颜色缓冲区，每次渲染会被重置，可以用异步修改里面的值

#### 1. 异步绘制点线

#### 2. 封装一个绘制类 

#### 3. 鼠标绘制线条

#### 4. 绘制多条线条

#### 5. 绘制一个星座图

需求

+ 顶点闪烁
+ 点击到一个已存在的点需要自动的以该点开始
